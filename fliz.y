/*
 * CS-252 Spring 2017
 * fiz.y: parser for the FIZ interpreter
 */


/********************************************************************************
 * Beginning of Section 1: Definition of tokens and non-terminal in the grammar *
 ********************************************************************************/ 

// tokens are generated by the lexical analyzer specified in fiz.l
// The ID token is used for function name, formal argument name, and usage of argument in function body
// its value is a string.  The token ID has a string value associated with it, here <string_val> refers
// to the "char *string_val" member in %union below
%token <string_val> ID			

// The token NUMBER has a integer value associated with it, here <number_val> refers to the 
// int number_val member in %union below
%token <number_val> NUMBER 

// These tokens do not have associated values
%token DEFINE HALT OPENPAR CLOSEPAR OPENBRK CLOSEBRK

// This declares that in the grammar, the non terminals expr, expr_list, and arg_list have 
// a value "struct TREE_NODE *node_val" associated with it
%type <node_val> expr expr_list arg_list

%type <value_node> const_expr const_list

%union    {
        char   *string_val;
        int    number_val;
        struct TREE_NODE *node_val;
        struct VALUE *value_node;
}

%{
/********************************************************************************
 * Beginning of Section 2: C data type and global variable definitions to be    *
 *  included in the generated y.tab.c file                                      *
 ********************************************************************************/ 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

void yyerror(const char * s);
void prompt();
int yylex();

#define MAX_FUNCTIONS 1000
#define MAX_ARGUMENTS 10
#define NUM_BUILTIN   5

enum VALUE_TYPE{
    NUMBER_VAL,LIST_VAL
};
struct VALUE {
    enum VALUE_TYPE type;
    union {
        struct {
            int numEle;
            int intValue;
        } number_val;
        struct {
            int numEle;
            struct VALUE** alist;
        } list_val;
    };
    struct VALUE * nextVal;
    struct VALUE * prevVal;
};


// The types of nodes that may occur in a syntax tree
enum NODE_TYPE
{
    HALT_NODE,      // corresponds to (halt)
    BUILTIN_FUNC,   // corresponds to built-in functions such as (inc ...) (dec ...) (ifz ... ... ...)
    FUNC_CALL,      // corresponds to (fname e1 e2 .. ek), where 1<=k<=MAX_ARGUMENTS 
                    // before the function is resolved, i.e., fname are still stored as strings
    FUNC_EVAL,      // corresponds to (fname e1 e2 .. ek), where 1<=k<=MAX_ARGUMENTS
                    // after the function has been resolved, that is, matching function has been found
    CONST_VALUE,    //
    ARG_NAME,       // corresponds to the usage of an ID in the body of the definition of a function,
                    // it indicates the usage of an argument, we are keeping it as a string
    ARG_INDEX,      // corresponds to the usage of an ID in the body of the definition of a function,
                    // it has been resolved to indicate the index of the argument 
    ARG_LIST        // corresponds to a list of formal arguments constructed during parsing in a function definition
};

// Below is the data type for a node in the syntax tree
struct TREE_NODE
{
    enum NODE_TYPE type;
    union {
        struct {
            struct BUILTIN_DECL *decl;
            int    numArgs;
            struct TREE_NODE *args[MAX_ARGUMENTS];
        } builtin_func;                      // For BUILTIN_FUNC
        struct {
            char *name;
            int    numArgs;
            struct TREE_NODE *args[MAX_ARGUMENTS];
        } func_call;                        // For FUNC_CALL
        struct {
            struct FUNC_DECL *func;
            int    numArgs;
            struct TREE_NODE *args[MAX_ARGUMENTS];
        } func_eval;                        // For FUNC_EVAL
        struct {
            int    numArgs;
            char * argNames[MAX_ARGUMENTS];
        } arg_list;                         // For ARG_LIST
        struct {
            struct VALUE *constValue;  	    // For CONST_VALUE
        } const_value;
        int    intValue;                    // For ARG_INDEX
        char   *strValue;                   // For ARG_NAME
    };
};

// Information we maintain for each built-in function
struct BUILTIN_DECL {
	char *name;
	int numArgs;
	struct VALUE* (* body)(struct TREE_NODE* node, struct VALUE **env);	// Body of the function
	void (* print)(FILE* stream, struct TREE_NODE* node, struct VALUE **env, int level) ;
					// support printing that occurs when tracing is on
};

// Information we maintain for each defined function
struct FUNC_DECL {
    char *name;              // Function name
    int  numArgs;            // Number of arguments
    char *argNames[MAX_ARGUMENTS];         // Names of formal arguments
    int  resolved;           // Whether the body expression has been resolved.
    struct TREE_NODE * body; // Point to the expression representing the body of a function
};

// Stores the definitions of functions defined using (define ...)
struct FUNC_DECL functions[MAX_FUNCTIONS];
int numFuncs = 0;

// Global variables
int err_value = 0;
int loading = 0;
int tracing = 0;
int depth = 0;

// Find a builtin function by name
struct BUILTIN_DECL * find_builtin(char *name);

// Find a function by name
struct FUNC_DECL * find_function(char *name);

// Resolve the body of a function to prepare it for evaluation
void resolve(struct TREE_NODE *node, struct FUNC_DECL *cf);

// Evaluate a function
struct VALUE *eval(struct TREE_NODE * node, struct VALUE **env);

// Free a syntax tree that is no longer needed
void free_tree(struct TREE_NODE *node);

void print_value(struct VALUE *v);


/*
 struct VALUE* eval_inc(struct TREE_NODE * node, struct VALUE **env);
 struct VALUE* eval_dec(struct TREE_NODE * node, struct VALUE **env);
 struct VALUE* eval_ifz(struct TREE_NODE * node, struct VALUE **env);
 */
struct VALUE* eval_head(struct TREE_NODE * node, struct VALUE **env);
struct VALUE* eval_tail(struct TREE_NODE * node, struct VALUE **env);
struct VALUE* eval_list(struct TREE_NODE * node, struct VALUE **env);
struct VALUE* eval_ifn(struct TREE_NODE * node, struct VALUE **env);
struct VALUE* eval_ifa(struct TREE_NODE * node, struct VALUE **env);

// Support printing when tracing is on
/*
 void print_inc(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
 void print_dec(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
 void print_ifz(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
 */
void print_head(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
void print_tail(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
void print_list(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
void print_ifn(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);
void print_ifa(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level);


// The global variable of all builtin functions
struct BUILTIN_DECL builtin_functions[NUM_BUILTIN] = {
/* 	{"inc", 1, &eval_inc, &print_inc},
    {"dec", 1, &eval_dec, &print_dec},
    {"ifz", 3, &eval_ifz, &print_ifz},
*/	{"head",1, &eval_head,  &print_head},
    {"tail",1, &eval_tail, &print_tail},
    {"list",2, &eval_list, &print_list},
    {"ifn", 3, &eval_ifn, &print_ifn},
    {"ifa", 3, &eval_ifa, &print_ifa}
    
};

%}

%%
/********************************************************************************
 * Beginning of Section 3: Grammar production rule definitions and associated   *
 *  C code                                                                      *
 ********************************************************************************/ 

statements:
 statement 
|
 statements statement
;

statement:
  OPENPAR DEFINE OPENPAR ID arg_list CLOSEPAR expr CLOSEPAR     // define a function`
  {
    if (find_builtin($4) != NULL) {
        fprintf(stderr, "Cannot redefine builtin function %s.\n", $4);
    } 
	else if (find_function($4) != NULL) {
        fprintf(stderr, "Function %s already defined.\n", $4);
    } 
	else if ($5-> arg_list.numArgs > MAX_ARGUMENTS) {
        fprintf(stderr, "Sorry, we allow only %d arguments in a function.", MAX_ARGUMENTS);
    } 
	else if (numFuncs == MAX_FUNCTIONS) {
        fprintf(stderr, "Sorry, we allow only %d number of functions to be defined. \n", MAX_FUNCTIONS);
    } 
	else {   // No error, add definition for the function
	    int i;
        functions[numFuncs].name = $4; 
        functions[numFuncs].numArgs = $5->arg_list.numArgs;
		for (i=0; i<$5->arg_list.numArgs; i++) {
            functions[numFuncs].argNames[i] = $5->arg_list.argNames[i];
		}
		free($5);
        functions[numFuncs].body = $7;
		// Do not resolve now, because the body may use function not yet defined. 
        functions[numFuncs].resolved = 0;	
        numFuncs++;
        printf("Function %s defined.\n", $4);
    }
  }
| 
  expr		// An expression
  {
    resolve($1, NULL);
    if (err_value == 0) {
       struct VALUE *v = eval($1, NULL);
       print_value(v);
       printf("\n");
    }
    err_value = 0;
  }
;

arg_list:
  ID 
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = ARG_LIST;
    node -> arg_list.numArgs = 1;
    node -> arg_list.argNames[0] = $1;
    $$ = node;
  }
| arg_list ID
  {
    if ($1 -> arg_list.numArgs >= MAX_ARGUMENTS) {
        fprintf (stderr, "Sorry, we allow at most %d arguments.\n", MAX_ARGUMENTS);		
        free($2);
		err_value = 1;
    } else {
        $1 -> arg_list.argNames[$1->arg_list.numArgs] = $2;
        $1 -> arg_list.numArgs++;
    }
    $$ = $1;
  }
  
expr_list:        
  expr
  {
    // expr_list can be used only as actual arguments in a function invocation
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = FUNC_CALL;
    node -> func_call.numArgs = 1;
    node -> func_call.args[0] = $1;
    $$ = node;
  }
| expr_list expr
  {
    if ($1 -> func_call.numArgs >= MAX_ARGUMENTS) {
        printf ("Sorry, we allow at most %d arguments.\n", MAX_ARGUMENTS);
        free_tree($2);
		err_value = 2;
    } else {
        $1 -> func_call.args[$1->func_call.numArgs] = $2;
        $1 -> func_call.numArgs++;
    }
    $$ = $1;
  }
;
  
expr: 
  OPENPAR HALT CLOSEPAR
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = HALT_NODE;
    $$ = node;
  }
|
  const_expr
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = CONST_VALUE;
    node -> const_value.constValue = $1;
    $$ = node;
  }
|
  ID
  {
    struct TREE_NODE * node = (struct TREE_NODE *) malloc(sizeof(struct TREE_NODE));
    node -> type = ARG_NAME;
    node -> strValue = $1;
    $$ = node;
  }
|
 OPENPAR ID expr_list CLOSEPAR
  {
    struct BUILTIN_DECL *builtin = find_builtin($2);
    $3 -> func_call.name = $2;
	if (builtin != NULL) {	// Usage of a built-in function
	    if (builtin->numArgs != $3->func_call.numArgs) {
		    fprintf (stderr, "The built-in function %s expects %d arguments; you have %d.", 
			                 builtin->name, builtin->numArgs, $3->func_call.numArgs);
			err_value = 3;
		} else {
	        $3 -> type = BUILTIN_FUNC;
		    $3 -> builtin_func.decl = builtin;
            free($2);			// Name string no longer needed
		}
    }
    $$ = $3;
  }
;


const_list:
const_expr
{
    
    /*struct VALUE * node = (struct VALUE *)malloc(sizeof(struct VALUE));
     if ($1->type == NUMBER_VAL){
     node->type = NUMBER_VAL;
     node->number_val.intValue = $1->number_val.intValue;
     node->number_val.numEle = 1;
     }else{
     node->type = LIST_VAL;
     node->list_val.numEle = $1->list_val.numEle;
     node->list_val.alist = (struct VALUE **)malloc(node->list_val.numEle * sizeof(struct VALUE*));
     int i = 0;
     for (i = i; i < node->list_val.numEle; i ++){
     node->list_val.alist[i] = $1->list_val.alist[i];
     }
     }
     $$ = node;
     */
    $$=$1;
}
|
const_list const_expr
{
    $1 -> prevVal -> nextVal = $2;
    $2 -> prevVal = $1 -> prevVal;
    $2 ->nextVal = $1;
    $1 -> prevVal = $2;
    // $$ = $1;
}
;

const_expr:
NUMBER
{
    struct VALUE * node = (struct VALUE *) malloc(sizeof(struct VALUE));
    node -> type = NUMBER_VAL;
    node -> number_val.intValue = $1;
    node -> number_val.numEle = 1;
    node->nextVal = node;
    node->prevVal = node;
    $$ = node;
}
|
OPENBRK CLOSEBRK
{
    struct VALUE * node = (struct VALUE *)malloc(sizeof(struct VALUE));
    node->type = LIST_VAL;
    node -> list_val.numEle = 0;
    node->nextVal = node;
    node->prevVal = node;
    $$ = node;
}
|
OPENBRK const_list CLOSEBRK
{
    
    //printf("constlist in const expr");
    struct VALUE * node = (struct VALUE *)malloc(sizeof(struct VALUE));
    node->type = LIST_VAL;
    int countEle = 0;
    struct VALUE *iterator = $2;
    do {
        countEle ++;
        iterator = iterator->nextVal;
    }while(iterator != $2);
    node->list_val.numEle = countEle;
    node->list_val.alist = (struct VALUE **)malloc(countEle * sizeof(struct VALUE*));
    iterator = $2;
    int i = 0;
    for (i=i;i<countEle;i++){
        node->list_val.alist[i] = iterator;
        iterator = iterator->nextVal;
    }
    node->nextVal = node;
    node->prevVal = node;
    $$ = node;
}
;


%%
/********************************************************************************
 * Beginning of Section 4: C functions to be included in the y.tab.c.           *
 ********************************************************************************/ 

/* Free an expression tree that is no longer needed.  */
void free_tree(struct TREE_NODE * node)
{
    int i;
    switch(node->type)
    {
        //case NUMBER_NODE:
        case ARG_INDEX:
        case HALT_NODE:
            break;
        case ARG_NAME:        
            free(node->strValue);
            break;
        case BUILTIN_FUNC:
            for (i=0; i<node->builtin_func.numArgs; i++) {
                free_tree(node->builtin_func.args[i]);
            }
            break;
        case FUNC_EVAL:
            for (i=0; i<node->func_eval.numArgs; i++) {
                free_tree(node->func_eval.args[i]);
            }
            break;
        case FUNC_CALL:
            free(node->func_call.name);
            for (i=0; i<node->func_call.numArgs; i++) {
                free_tree(node->func_call.args[i]);
            }
            break;
        case ARG_LIST:
            for (i=0; i<node->arg_list.numArgs; i++) {
                free(node->arg_list.argNames[i]);
            }
            break;
        default:
            fprintf(stderr, "Unexpected node type during freeing.\n");
            exit(1);
    }
    free(node);
}

/* Print an expression when tracing is on */
void print_node(struct TREE_NODE * node, int *env, int level)
{/*
    int i;
    struct FUNC_DECL *f;
    switch(node->type)
    {
        case NUMBER_NODE:
            printf (" %d", node->intValue);
            return;
        case ARG_INDEX:
            printf (" %d", env[node->intValue]);
            return;
        case BUILTIN_FUNC:
			node->builtin_func.decl->print(stdout, node, env, level);
            return;
        case HALT_NODE:
            printf (" (halt)");
            return;
        case FUNC_EVAL:
            f = node->func_eval.func;
            printf (" (%s", f->name);
            for (i=0; i<f->numArgs; i++) {
                if (level == 0) {
                    printf(" ..");
                } else {
                    print_node(node->func_eval.args[i], env, level-1);
                }
            }
            printf (")");
            return;
        default:
            fprintf(stderr, "Unexpected node type during evaluation.\n");
            exit(1);
    }
*/}

struct BUILTIN_DECL * find_builtin(char *name)
{
    int i;
    for (i=0; i<NUM_BUILTIN; i++) {
        if (strcmp(builtin_functions[i].name, name) == 0)
            return &builtin_functions[i];
    }
    return NULL;
}

 
struct FUNC_DECL * find_function(char *name)
{
    int i;
    for (i=0; i<numFuncs; i++) {
        if (! strcmp(functions[i].name, name))
            return &functions[i];
    }
    return NULL;
}

/* Resolve an expression pointed to by node, possibly in the context of a function 
   body.  */
void resolve(struct TREE_NODE *node, struct FUNC_DECL *cf)
{
    struct FUNC_DECL *f = NULL;

    int i;
    switch(node->type)
    {
        case ARG_NAME:        // Use of an argument
            if (cf != NULL) { //
                for (i=0; i<cf->numArgs; i++) {
                    if (! strcmp(node->strValue, cf->argNames[i])) {
                        free(node->strValue);
                        node->type = ARG_INDEX;
                        node->intValue = i;
                        break;
                    }
                }
            }
            if (node->type != ARG_INDEX) {
                fprintf(stderr, "Usage of identifier %s undefined\n", node->strValue);
                err_value = 1;
            }
            break;
            
        case FUNC_CALL:
            f = find_function(node->func_call.name);
            if (f == NULL) {
                fprintf(stderr, "Function %s not found\n", node->func_call.name);
                err_value = 1;
                break;
            }
            if (f->numArgs != node->func_call.numArgs) {
                fprintf(stderr, "Usage of function %s has %d arguments, definition of function %s has %d arguments.\n", 
                       f->name, node->func_eval.numArgs, f->name, f->numArgs);
                err_value = 1;
                break;
            }
            free(node->func_call.name);
            for (i=0; i<f->numArgs; i++) {
                resolve(node->func_call.args[i], cf);
            }
            node->type = FUNC_EVAL;
            node->func_eval.func = f;
            break;

        case BUILTIN_FUNC:
            for (i=0; i<node->builtin_func.numArgs; i++) {
                resolve(node->builtin_func.args[i], cf);
            }
			break;
    }
}

//Evaluates an expression node
struct VALUE * eval(struct TREE_NODE * node, struct VALUE **env)
{
    struct FUNC_DECL *f;
    int i;
    struct VALUE* v;
    struct VALUE *e[MAX_ARGUMENTS];
    depth ++;

    switch(node->type)
    {
        case CONST_VALUE:
            v = node->const_value.constValue;
            break;
        case ARG_INDEX:
            v = env[node->intValue];
            break;
        case BUILTIN_FUNC:
            v= (node->builtin_func.decl->body)(node, env);
            break;

        case HALT_NODE:
            fprintf(stderr, "Halted\n");
            exit(1);
            
        case FUNC_EVAL:
            f = node->func_eval.func;
            if (! f->resolved) {
                resolve(f->body, f);
            }
            
            for (i=0; i<f->numArgs; i++) {
                e[i] = eval(node->func_eval.args[i], env);
            }
            /*
            if (tracing) {
                for (i=0; i<depth; i++) {
                    printf (" ");
                }
                printf("Evaluating (%s", f->name); 
                for (i=0; i<f->numArgs; i++) {
                    printf (" %d", e[i]);
                }
                printf(")\n");
            }
            */
            v = eval(f->body, e);
            /*
            if (tracing) {
                for (i=0; i<depth; i++) {
                    printf (" ");
                }
                printf("(%s", f->name); 
                for (i=0; i<f->numArgs; i++) {
                    printf (" %d", e[i]);
                }
                printf(") = %d\n", v);
            }
            */
            break;

        default:
            fprintf (stderr, "Unexpected node %d\n", node->type); 
            exit(3);
    }
    depth --;
    return v;
}

/*********************************************************
 * Begin of supporting code for the built-in functions.  *
 *********************************************************/
void print_value(struct VALUE *v)
{
    if(v->type == NUMBER_VAL) {
        fprintf(stdout, "%d ", v->number_val.intValue);
    } else {
        fprintf(stdout, "[ ");
        int i = 0;
        struct VALUE * temp;
        for (i=i; i < v->list_val.numEle;i++){
            temp = v->list_val.alist[i];
            print_value(temp);
        }
        fprintf(stdout, "] ");
    }
}


struct VALUE* eval_head(struct TREE_NODE * node, struct VALUE** env){
    struct VALUE* temp = eval(node->builtin_func.args[0], env);
    if (temp->type == LIST_VAL && temp->list_val.numEle != 0){
        struct VALUE* ret = temp->list_val.alist[0];
        ret->prevVal = ret;
        ret->nextVal= ret;
        return ret;
    } else {
        printf("atotmic or [] value in head\n");
        exit(0);
        return NULL;
        struct VALUE * ret = (struct VALUE*)malloc(sizeof(struct VALUE));
        ret->type = LIST_VAL;
        ret->list_val.numEle = 0;
        return ret;

    }
}

void print_head(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level){}




struct VALUE* eval_tail(struct TREE_NODE * node, struct VALUE** env){
    struct VALUE* temp = eval(node->builtin_func.args[0], env);
    
    if (temp->type == LIST_VAL && temp->list_val.numEle != 0){
        int numEle = temp->list_val.numEle;
        struct VALUE* ret = (struct VALUE*)malloc(sizeof(struct VALUE));
        ret->nextVal = ret;
        ret->prevVal = ret;
        ret->type = LIST_VAL;
        ret->list_val.numEle = numEle-1;
        
        if(ret->list_val.numEle == 0)
        {
            ret->list_val.alist = (struct VALUE**)malloc(0*sizeof(struct VALUE*));
            return ret;
        }
        
        ret->list_val.alist = (struct VALUE**)malloc((numEle -1)*sizeof(struct VALUE*));
        int i = 0;
        for (i = 0; i < (numEle-1); i++){
            ret->list_val.alist[i] = temp->list_val.alist[i+1];
        }
        
        ret->list_val.alist[numEle-2]->nextVal = ret->list_val.alist[0];
        ret->list_val.alist[0]->prevVal = ret->list_val.alist[numEle-2];
        return ret;
    }
    else if (temp->type = NUMBER_VAL){
        printf("\neval tail has a number as argument\n");
        exit(1);
    } else {
        printf("\neval tail has a [] as argument\n");
        exit(1);
    }
    
}

void print_tail(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level){}




struct VALUE* eval_list(struct TREE_NODE * node, struct VALUE** env){
    struct VALUE* temp2 = eval(node->builtin_func.args[1], env);
    
    if (temp2->type == NUMBER_VAL) {
        printf("\neval list has a number as 2nd argument\n");
        exit(1);
    }
    
    int numEle2 = temp2->list_val.numEle;
    struct VALUE* ret = (struct VALUE*)malloc(sizeof(struct VALUE));
    ret->nextVal= ret;
    ret->prevVal = ret;
    ret->type = LIST_VAL;
    ret->list_val.numEle = numEle2 + 1;
    ret->list_val.alist = (struct VALUE**)malloc((numEle2+1)*sizeof(struct VALUE*));
    
    ret->list_val.alist[0] = eval(node->builtin_func.args[0], env);
    
    int i = 1;
    for (i = 1; i < ret->list_val.numEle; i++){
        ret->list_val.alist[i] = temp2->list_val.alist[i-1];
    }
    
    if(ret->list_val.numEle > 1){
        ret->list_val.alist[numEle2]->nextVal= ret->list_val.alist[0];
        ret->list_val.alist[1]->prevVal = ret->list_val.alist[0];
    }
    ret->list_val.alist[0]->nextVal= ret->list_val.alist[1];
    ret->list_val.alist[0]->prevVal = ret->list_val.alist[numEle2];
    return ret;
}

void print_list(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level){}




struct VALUE* eval_ifn(struct TREE_NODE * node, struct VALUE** env){
    struct VALUE* temp1 = eval(node->builtin_func.args[0], env);
    struct VALUE* temp2 = eval(node->builtin_func.args[1], env);
    if (temp1->list_val.numEle == 0 && temp1->type == LIST_VAL){
        return temp2;
    } else {
        struct VALUE * temp3 = eval(node->builtin_func.args[2], env);
        return temp3;
    }
}

void print_ifn(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level){}




struct VALUE* eval_ifa(struct TREE_NODE * node, struct VALUE** env){
    struct VALUE * temp1 = eval(node->builtin_func.args[0], env);
    struct VALUE * temp2 = eval(node->builtin_func.args[1], env);
    if (temp1->type == NUMBER_VAL) return temp2;
    else {
        struct VALUE * temp3 = eval(node->builtin_func.args[2], env);
        return temp3;
    }
}

void print_ifa(FILE *stream, struct TREE_NODE * node, struct VALUE **env, int level){}


/*
int eval_inc(struct TREE_NODE * node, int *env)
{
    return eval(node->builtin_func.args[0], env) + 1;
}

void print_inc(FILE *stream, struct TREE_NODE * node, int *env, int level)
{
	fprintf (stream, " (inc ..)");
}
            
int eval_dec(struct TREE_NODE * node, int *env)
{
    int v = eval(node->builtin_func.args[0], env) - 1;
	if (v < 0) {
	    fprintf(stderr, "Encountering a negative number.  Exiting.\n");
		exit(1);
	}
	return v;
}

void print_dec(FILE *stream, struct TREE_NODE * node, int *env, int level)
{
	fprintf (stream, " (dec ..)");
}

int eval_ifz(struct TREE_NODE * node, int *env)
{
    int i;
    int v = eval(node->builtin_func.args[0], env);
            
    if (tracing) {
        for (i=0; i<depth; i++) {
            printf (" ");
        }
        printf("Evaluating (ifz %d", v);
        print_node(node->builtin_func.args[1], env, 2);
        print_node(node->builtin_func.args[2], env, 2);
        printf(")\n");
    }

    if (v == 0) 
        v = eval(node->builtin_func.args[1], env);
    else
        v = eval(node->builtin_func.args[2], env);
    return v;
}

void print_ifz(FILE *stream, struct TREE_NODE * node, int *env, int level)
{
    if (level == 0) {
        printf (" (ifz .. .. ..)");
    } else {
        printf (" (ifz");
        print_node(node->builtin_func.args[0], env, level-1);
        print_node(node->builtin_func.args[1], env, level-1);
        print_node(node->builtin_func.args[2], env, level-1);
        printf (")");
    }
}
*/
/*********************************************************
 * End of supporting code for the built-in functions.  *
 *********************************************************/

void yyerror(const char * s)
{
    fprintf(stderr,"%s", s);
}

void prompt()
{
    if (! loading) {
        printf("fiz> ");
    }
}

main(int argc, char *argv[])
{
    prompt();
    yyparse();
    return 0;
}
    
